;+
; NAME: make_apmask
;
; Description:
;  Find the indices of an elliptical region in a 2D array.  Default shape is a circle.  Optionally provides the fraction
;  of each pixel included in the aperture.
;
; INPUTS:
;  x0  :  the x center of the mask (pixels), relative to the center of the xarr/yarr arrays
;  y0  :  the y center of the mask (pixels), relative to the center of the xarr/yarr arrays
;  semimaj : the semi-major axis of the ellipse
;  xarr : 2D array of x values, as generated by rarr.pro -or- a single value specifying the size of the array
;  yarr : 2D array of y values, as generated by rarr.pro -or- a single value specifying the size of the array
;
; INPUT KEYWORDS:
;  axrat    :  the ratio semi-minor/semi-major of the ellipse.  If 1 or not set this makes a circle.
;  pa       :  the PA of the ellipse, in degrees. if axrat = 1 this is ignored.
;  skywidth :  if this is set, a circular annulus from semimaj to semimaj+skywidth is returned
;
; OUTPUTS:
;  Returns a vector if indices defining the masked pixels.
;
;
; EXAMPLE:
;  idx = make_apmask(45,45, 4, xarr, yarr, axrat=.5, pa=45.)
;       this returns an elliptical mask, centered at pixel 45X45, with axes of size 4 and 2 pixels, at pa=45 degrees.
;
;  idx = make_apmask(45,45, 5., xarr, yarr, skywidth=2.)
;       this returns an annulus of inner radius 5 and outer radius 7
;
; HISTORY:
;  2013-03-13 Written by Jared Males, jrmales@email.arizona.edu
;
;-
function make_apmask, x0, y0, semimaj,  xarr, yarr, axrat=axrat, pa=pa, skywidth=skywidth, frac=frac, simplefrac=simplefrac

if(n_elements(axrat) ne 1) then axrat = 1.
if(n_elements(pa) ne 1) then pa = 0.

if n_elements(xarr) eq 1 then r=rarr(float(xarr*1.), float(yarr*1.), xarr, yarr, /pix)

r = sqrt((yarr-y0)^2 +  (xarr-x0)^2)

dofrac = 0
if(arg_present(frac) and ~keyword_set(simplefrac)) then begin
   dofrac = 1
endif


;Here we calculate a circular sky buffer
if(keyword_set(skywidth)) then begin
   
   idx = where(r ge semimaj and r le semimaj+skywidth)
  
   return, idx
   
endif

rmax = sqrt( (xarr+ 0.5*sign(xarr-x0) - x0)^2 + (yarr+ 0.5*sign(yarr-y0)  - y0 )^2)

rmin = pixel_rmin(xarr, yarr, x0  , y0)

;Ok, it's just a circle, return as fast as possible
if(axrat eq 1) then begin

   idx = where(rmin lt semimaj)
      
   if(dofrac) then begin
      frac = fltarr(n_elements(idx))
      for i=0l, n_elements(idx)-1 do begin
         if(semimaj gt rmax[idx[i]]) then begin
            frac[i] = 1.
         endif else begin
            w = pixel_circle_intcpt((xarr[idx[i]]-x0)*sign(xarr[idx[i]]-x0), (yarr[idx[i]]-y0)*sign(yarr[idx[i]]-y0), semimaj)
            frac[i] = frac_pixel(semimaj, w=w)
;         
            if(~finite(frac[i])) then frac[i] = 1.
         endelse
      endfor

      edx = where(frac lt 0. or frac gt 1.)
      if(edx[0] ne -1) then frac[edx] = 0.
   
   endif else begin;dofrac
      frac = fltarr(n_elements(idx)) + 1.
   endelse
   
   return, idx
   
endif

;Here we do an actual ellipse.

theta = atan(yarr-floor(y0+.5), xarr-floor(x0+.5)) - pa*!dtor

rellip = semimaj^2*axrat/sqrt((axrat*semimaj*cos(theta))^2 + (semimaj*sin(theta))^2)


idx = where(r le rellip)

frac = fltarr(n_elements(idx)) + 1.

return, idx

end
